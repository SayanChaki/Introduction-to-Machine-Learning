# -*- coding: utf-8 -*-
"""Question2 KNN.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1b_vJV7v1-9Lm6gWCJEFBqVBZfSNvzksj
"""

import numpy as np
from sklearn.cluster import KMeans
from sklearn.preprocessing import StandardScaler
import matplotlib.pyplot as plt

# Generate synthetic customer dataset (age, spending)
def generate_customer_data(n_samples=300):
    np.random.seed(42)
    # Cluster 1: Young, high spenders
    c1 = np.random.multivariate_normal([25, 80], [[5, 10], [10, 100]], n_samples // 3)
    # Cluster 2: Middle-aged, moderate spenders
    c2 = np.random.multivariate_normal([40, 50], [[8, 5], [5, 50]], n_samples // 3)
    # Cluster 3: Older, low spenders
    c3 = np.random.multivariate_normal([60, 20], [[5, 5], [5, 30]], n_samples // 3)
    X = np.vstack([c1, c2, c3])
    return X

class KMeansClusterer:
    def __init__(self, max_k=10):
        self.max_k = max_k
        self.random_state = 42
        self.inertias = []

    def fit_elbow(self, X):
        """
        TODO: Complete this method to:
        - Fit K-Means for K=1 to self.max_k
        - Compute inertia (sum of squared distances to centroids) for each K
        - Plot the elbow curve (K vs. inertia)
        - Return the optimal K (e.g., based on visual inspection or heuristic)
        """
        # Placeholder: Students must replace this
        return optimal_k

    def fit_and_predict(self, X, k_optimal):
        kmeans = KMeans(n_clusters=k_optimal, random_state=self.random_state, n_init=10)
        kmeans.fit(X)
        return kmeans.labels_

# Main script to run the clustering
if __name__ == "__main__":
    # Generate and preprocess data
    X = generate_customer_data()
    scaler = StandardScaler()
    X_scaled = scaler.fit_transform(X)

    # Initialize and run clustering
    clusterer = KMeansClusterer(max_k=10)
    optimal_k = clusterer.fit_elbow(X_scaled)

    # Fit with optimal K and visualize clusters
    if optimal_k:
        labels = clusterer.fit_and_predict(X_scaled, optimal_k)
        X_unscaled = scaler.inverse_transform(X_scaled)  # For visualization
        plt.scatter(X_unscaled[:, 0], X_unscaled[:, 1], c=labels, cmap='viridis')
        plt.xlabel('Age')
        plt.ylabel('Annual Spending ($K)')
        plt.title(f'K-Means Clustering with K={optimal_k}')
        plt.show()
    else:
        print("Elbow method failed to determine optimal K.")

